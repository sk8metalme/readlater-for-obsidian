// ReadLater for Obsidian - Aggregated Markdown Generator
// 集約Markdownファイル全体の生成を担当するクラス

// Note: MarkdownGeneratorとArticleTableManagerはグローバルスコープから取得
// require()を使用するとimportScripts()との競合が発生するため削除

/**
 * 集約Markdownファイル生成クラス
 */
class AggregatedMarkdownGenerator {
    constructor(dependencies = {}) {
        // 依存関係の注入（テスト用）
        // グローバルスコープからクラスを取得（importScriptsまたはブラウザ環境で読み込まれている）
        const MarkdownGeneratorClass = dependencies.markdownGenerator ? dependencies.markdownGenerator.constructor : 
            (typeof MarkdownGenerator !== 'undefined' ? MarkdownGenerator : null);
        const ArticleTableManagerClass = dependencies.tableManager ? dependencies.tableManager.constructor :
            (typeof ArticleTableManager !== 'undefined' ? ArticleTableManager : null);
        
        this.markdownGenerator = dependencies.markdownGenerator || 
            (MarkdownGeneratorClass ? new MarkdownGeneratorClass() : null);
        this.tableManager = dependencies.tableManager || 
            (ArticleTableManagerClass ? new ArticleTableManagerClass() : null);
        
        this.options = {
            includeTableOfContents: true,
            includeSummaryStats: true,
            defaultTitle: 'ReadLater Articles',
            ...dependencies.options
        };
        
        // エラーハンドラーの初期化
        const ErrorHandlerClass = typeof ErrorHandler !== 'undefined' ? ErrorHandler : null;
        this.errorHandler = dependencies.errorHandler || 
            (ErrorHandlerClass ? new ErrorHandlerClass() : {
                handleError: (e) => ({ error: e?.message }),
                retry: async (fn) => fn()
            });
    }

    /**
     * 複数記事から集約Markdownを生成
     * @param {Array<Object>} articles - 記事配列
     * @param {Object} settings - ユーザー設定
     * @returns {Promise<string>} 集約Markdownコンテンツ
     */
    async generateAggregatedMarkdown(articles, settings) {
        try {
            // バリデーション
            if (!Array.isArray(articles)) {
                throw new Error('記事配列が無効です');
            }
            
            if (articles.length === 0) {
                console.warn('AggregatedMarkdownGenerator: Empty articles array provided');
            }
            
            if (!settings) {
                throw new Error('設定データが不完全です');
            }

            const sections = [];

            // ファイルヘッダー
            try {
                sections.push(this.generateFileHeader(settings));
            } catch (error) {
                console.warn('AggregatedMarkdownGenerator: Header generation failed, using fallback');
                sections.push(`# ${this.options.defaultTitle}\n`);
            }

            // 目次（オプション）
            if (this.options.includeTableOfContents) {
                try {
                    sections.push(this.generateTableOfContents(articles));
                } catch (error) {
                    console.warn('AggregatedMarkdownGenerator: TOC generation failed, skipping');
                }
            }

            // 記事一覧表
            try {
                sections.push(this.generateArticleTable(articles, settings));
            } catch (error) {
                console.warn('AggregatedMarkdownGenerator: Table generation failed, using fallback');
                sections.push('## 記事一覧\n\n記事一覧の生成に失敗しました。\n');
            }

            // 記事詳細セクション
            try {
                sections.push(this.generateArticleDetailsSection(articles));
            } catch (error) {
                console.warn('AggregatedMarkdownGenerator: Article details generation failed, using fallback');
                sections.push('## 📖 記事詳細\n\n記事詳細の生成に失敗しました。\n');
            }

            // ファイルフッター
            try {
                sections.push(this.generateFileFooter(articles.length));
            } catch (error) {
                console.warn('AggregatedMarkdownGenerator: Footer generation failed, using fallback');
                sections.push('\n---\n*Generated by ReadLater for Obsidian*');
            }

            return sections.join('\n\n');
            
        } catch (error) {
            const errorResult = this.errorHandler.handleError(
                new Error(`集約Markdown生成に失敗: ${error.message}`),
                { 
                    operation: 'generateAggregatedMarkdown', 
                    articlesCount: articles?.length || 0,
                    settingsValid: !!settings
                }
            );
            throw error;
        }
    }

    /**
     * 既存コンテンツに記事を追加
     * @param {string} existingContent - 既存ファイル内容
     * @param {Object} newArticle - 新規記事
     * @param {Object} settings - ユーザー設定
     * @returns {Promise<string>} 更新されたコンテンツ
     */
    async appendArticleContent(existingContent, newArticle, settings) {
        if (!existingContent || !this.isValidAggregatedFile(existingContent)) {
            // 無効なファイルの場合は新規作成
            return await this.generateAggregatedMarkdown([newArticle], settings);
        }

        let updatedContent = existingContent;

        // テーブルセクションの更新
        updatedContent = this.appendToArticleTable(updatedContent, newArticle, settings);

        // 詳細セクションに記事を追加
        updatedContent = this.appendToDetailsSection(updatedContent, newArticle);

        // 目次の更新
        updatedContent = this.updateTableOfContents(updatedContent);

        return updatedContent;
    }

    /**
     * ファイルヘッダーの生成（フロントマター付き）
     * @param {Object} settings - ユーザー設定
     * @returns {string} ファイルヘッダー
     */
    generateFileHeader(settings) {
        const title = settings.title || this.options.defaultTitle;
        const now = new Date().toISOString().split('T')[0];
        const timestamp = new Date().toISOString();
        
        // フロントマター生成（既存のMarkdownGeneratorパターンを踏襲）
        const frontmatter = `---
title: "${title}"
type: "aggregated-articles"
created: "${timestamp}"
updated: "${timestamp}"
tags: ["ReadLater", "aggregated", "articles"]
cssclass: "readlater-aggregated"
total_articles: 0
---`;

        return `${frontmatter}

# ${title}

> 📚 ReadLater for Obsidianで保存した記事の集約ファイルです  
> 🗓️ **作成日**: ${now} | **最終更新**: ${now}

`;
    }

    /**
     * 目次の生成
     * @param {Array<Object>} articles - 記事配列
     * @returns {string} 目次セクション
     */
    generateTableOfContents(articles) {
        if (!articles || articles.length === 0) {
            return `## 目次

記事はまだ保存されていません。`;
        }

        const tocItems = articles.map(article => {
            const anchor = this.createAnchorLink(article.title);
            return `- [${article.title}](#${anchor})`;
        });

        return `## 目次

${tocItems.join('\n')}`;
    }

    /**
     * 記事一覧表の生成（標準テンプレート構造）
     * @param {Array<Object>} articles - 記事配列
     * @param {Object} settings - ユーザー設定
     * @returns {string} 記事一覧表セクション
     */
    generateArticleTable(articles, settings) {
        const sectionHeader = `## 📋 記事一覧

> 保存された記事の概要一覧です。タイトルをクリックすると詳細セクションにジャンプできます。

`;
        
        const header = this.tableManager.generateTableHeader(settings.tableColumns);
        
        if (!articles || articles.length === 0) {
            return sectionHeader + header + '\n\n*まだ記事が保存されていません。*';
        }

        const rows = articles.map(article => 
            this.tableManager.formatTableRow(article, settings.tableColumns)
        );

        const summaryStats = `
### 📊 統計情報
- **総記事数**: ${articles.length}件
- **最新保存**: ${this.getLatestSaveDate(articles)}
- **言語分布**: ${this.getLanguageDistribution(articles)}

`;

        return sectionHeader + summaryStats + header + '\n' + rows.join('\n');
    }

    /**
     * 記事詳細セクション全体の生成（標準テンプレート構造）
     * @param {Array<Object>} articles - 記事配列
     * @returns {string} 記事詳細セクション
     */
    generateArticleDetailsSection(articles) {
        const sectionHeader = `## 📖 記事詳細

> 各記事の完全な翻訳内容と詳細情報です。

`;

        if (!articles || articles.length === 0) {
            return sectionHeader + '*まだ記事が保存されていません。記事を保存すると、ここに詳細内容が表示されます。*';
        }

        const sections = articles.map(article => 
            this.generateArticleDetailSection(article)
        );

        return sectionHeader + sections.join('\n\n---\n\n');
    }

    /**
     * 個別記事の詳細セクションを生成（MarkdownGeneratorのパターンを踏襲）
     * @param {Object} article - 記事データ
     * @returns {string} 記事詳細セクション
     */
    generateArticleDetailSection(article) {
        const sections = [];
        
        // 記事タイトル（アンカーリンク対応）
        sections.push(`### ${article.title}`);
        
        // 記事メタ情報（MarkdownGeneratorのgenerateArticleInfoパターン）
        const metadata = this.generateArticleMetadata(article);
        sections.push(metadata);
        
        // AI要約セクション（利用可能な場合）
        if (article.summary && !article.summarySkipped) {
            sections.push(`#### 📄 AI要約\n\n${article.summary}`);
        }
        
        // メインコンテンツセクション（翻訳優先）
        if (article.translatedContent && !article.translationSkipped) {
            sections.push(`#### 📖 翻訳済み記事内容\n\n${article.translatedContent}`);
            
            // 翻訳エラーがあれば注記
            if (article.translationError) {
                sections.push(`*⚠️ 翻訳処理中にエラーが発生しました: ${article.translationError}*`);
            }
            
            // 原文（折りたたみ形式、MarkdownGeneratorと同様）
            if (article.content) {
                sections.push(`<details>\n<summary>📄 原文を表示</summary>\n\n${article.content}\n\n</details>`);
            }
        } else {
            sections.push(`#### 📖 記事内容\n\n${article.content || 'コンテンツが取得できませんでした。'}`);
            
            // 翻訳がスキップされた理由があれば表示
            if (article.translationSkipped && article.translationError) {
                sections.push(`*ℹ️ 翻訳はスキップされました: ${article.translationError}*`);
            }
        }
        
        return sections.join('\n\n');
    }

    /**
     * 目次を更新
     * @param {string} content - ファイルコンテンツ
     * @returns {string} 更新されたコンテンツ
     */
    updateTableOfContents(content) {
        // 記事タイトルを抽出
        const titleMatches = content.match(/### (.+)/g);
        const articles = titleMatches ? titleMatches.map(match => ({
            title: match.replace('### ', '')
        })) : [];

        // 新しい目次を生成
        const newToc = this.generateTableOfContents(articles);

        // 既存の目次を置換
        const tocRegex = /## 目次[\s\S]*?(?=\n## (?!目次)|$)/;
        if (tocRegex.test(content)) {
            return content.replace(tocRegex, newToc);
        } else {
            // 目次がない場合は追加
            const headerEndIndex = content.indexOf('\n\n') + 2;
            return content.slice(0, headerEndIndex) + newToc + '\n\n' + content.slice(headerEndIndex);
        }
    }

    /**
     * ファイルフッターの生成（MarkdownGeneratorのパターンを踏襲）
     * @param {number} articleCount - 記事数
     * @returns {string} ファイルフッター
     */
    generateFileFooter(articleCount) {
        const timestamp = new Date().toLocaleString('ja-JP');
        const now = new Date().toISOString().split('T')[0];
        
        return `
---

## 📈 ファイル情報

- **📊 総記事数**: ${articleCount}件
- **📅 最終更新**: ${now}
- **🕒 更新時刻**: ${timestamp}
- **📱 生成元**: ReadLater for Obsidian
- **📝 ファイル形式**: 集約型Markdownファイル

---

*📱 Generated by ReadLater for Obsidian*  
*🕒 ${timestamp}*  
*🎯 Mode: Aggregated Articles*`;
    }

    /**
     * アンカーリンクの作成
     * @param {string} title - タイトル
     * @returns {string} アンカーリンク
     */
    createAnchorLink(title) {
        return title
            .toLowerCase()
            .replace(/[^a-z0-9\u3040-\u309f\u30a0-\u30ff\u4e00-\u9faf\s]/g, '-')
            .replace(/\s+/g, '-')
            .replace(/&/g, '-')
            .replace(/-+/g, '-')
            .replace(/^-|-$/g, '');
    }

    /**
     * 記事テーブルに新規記事を追加
     * @param {string} content - ファイルコンテンツ
     * @param {Object} article - 新規記事
     * @param {Object} settings - ユーザー設定
     * @returns {string} 更新されたコンテンツ
     */
    appendToArticleTable(content, article, settings) {
        // テーブルセクションを抽出
        const tableRegex = /(\| タイトル \|[\s\S]*?)(?=\n## |$)/;
        const tableMatch = content.match(tableRegex);
        
        if (tableMatch) {
            const existingTable = tableMatch[1];
            const updatedTable = this.tableManager.addArticleToTable(article, existingTable);
            return content.replace(tableMatch[1], updatedTable);
        }
        
        return content;
    }

    /**
     * 詳細セクションに記事を追加
     * @param {string} content - ファイルコンテンツ
     * @param {Object} article - 新規記事
     * @returns {string} 更新されたコンテンツ
     */
    appendToDetailsSection(content, article) {
        const newDetail = this.generateArticleDetailSection(article);
        
        // 詳細セクションの最後に追加
        const detailsRegex = /(## 記事詳細[\s\S]*?)(\n---)/;
        const detailsMatch = content.match(detailsRegex);
        
        if (detailsMatch) {
            const updatedDetails = detailsMatch[1] + '\n\n' + newDetail;
            return content.replace(detailsMatch[1], updatedDetails);
        } else {
            // 詳細セクションが見つからない場合はファイル末尾に追加
            return content + '\n\n' + newDetail;
        }
    }

    /**
     * 有効な集約ファイルかチェック
     * @param {string} content - ファイルコンテンツ
     * @returns {boolean} 有効かどうか
     */
    isValidAggregatedFile(content) {
        if (!content || typeof content !== 'string') {
            return false;
        }

        // 必要なセクションの存在確認
        const hasTitle = /^# /.test(content) || /\n# /.test(content); // フロントマター対応
        const hasTable = /\| タイトル \|/.test(content);
        const hasDetails = /## 📖 記事詳細/.test(content);

        return hasTitle && hasTable && hasDetails;
    }

    /**
     * 記事メタデータ情報の生成（MarkdownGeneratorのパターンを踏襲）
     * @param {Object} article - 記事データ
     * @returns {string} メタデータ情報
     */
    generateArticleMetadata(article) {
        const date = article.savedDate instanceof Date ? 
            article.savedDate.toISOString().split('T')[0] : 
            String(article.savedDate || '');
        
        let info = `**📍 元記事**: [${article.title}](${article.url})\n`;
        info += `**🌐 ドメイン**: ${article.domain || new URL(article.url).hostname}\n`;
        info += `**📅 保存日**: ${date}\n`;
        
        if (article.author && article.author !== 'Unknown') {
            info += `**✍️ 著者**: ${article.author}\n`;
        }
        
        if (article.language && article.language !== 'unknown') {
            info += `**🗣️ 言語**: ${article.language}\n`;
        }
        
        if (article.detectedLanguage && article.detectedLanguage !== 'unknown') {
            info += `**🔍 検出言語**: ${article.detectedLanguage}\n`;
        }
        
        if (article.readingTime && article.readingTime !== 'Unknown') {
            info += `**⏱️ 読了時間**: 約${article.readingTime}分\n`;
        }
        
        return info;
    }

    /**
     * 最新保存日を取得
     * @param {Array<Object>} articles - 記事配列
     * @returns {string} 最新保存日
     */
    getLatestSaveDate(articles) {
        if (!articles || articles.length === 0) return '未保存';
        
        const dates = articles.map(article => {
            const date = article.savedDate instanceof Date ? 
                article.savedDate : 
                new Date(article.savedDate || 0);
            return date;
        });
        
        const latest = new Date(Math.max(...dates));
        return latest.toISOString().split('T')[0];
    }

    /**
     * 言語分布を取得
     * @param {Array<Object>} articles - 記事配列
     * @returns {string} 言語分布の文字列
     */
    getLanguageDistribution(articles) {
        if (!articles || articles.length === 0) return 'なし';
        
        const langCount = {};
        articles.forEach(article => {
            const lang = article.detectedLanguage || article.language || 'unknown';
            langCount[lang] = (langCount[lang] || 0) + 1;
        });
        
        const langEntries = Object.entries(langCount)
            .sort((a, b) => b[1] - a[1]) // 件数順でソート
            .slice(0, 3) // 上位3つ
            .map(([lang, count]) => `${lang}(${count})`);
        
        return langEntries.join(', ');
    }

    /**
     * 標準集約ファイルテンプレート構造を取得
     * @param {Object} settings - ユーザー設定
     * @returns {string} テンプレート構造の説明
     */
    getStandardTemplateStructure(settings) {
        const title = settings.title || this.options.defaultTitle;
        
        return `# 集約ファイル標準テンプレート構造

以下は${title}で使用される標準的なMarkdown構造です：

## 1. ファイルヘッダー（フロントマター + タイトル）
- YAML形式のObsidian互換メタデータ
- 集約ファイル識別タグ
- 作成・更新日時
- 総記事数カウンター

## 2. 目次セクション
- 保存された記事のナビゲーション
- 記事タイトルから詳細セクションへのアンカーリンク
- 動的更新による最新状態の維持

## 3. 記事一覧表セクション
- 統計情報（記事数、最新保存日、言語分布）
- Markdown表形式の記事リスト
- 各行：タイトル、URL、要約、保存日、言語

## 4. 記事詳細セクション
- 各記事の完全なコンテンツ
- 翻訳済み内容（利用可能な場合）
- AI生成要約
- 原文（折りたたみ表示）
- メタデータ情報

## 5. ファイルフッター
- ファイル情報（記事数、更新日時）
- ReadLater for Obsidianの署名
- 集約モード識別子

このテンプレート構造により、記事の概要把握から詳細閲覧まで
効率的なワークフローが実現されます。`;
    }
}

// モジュールのエクスポート
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { AggregatedMarkdownGenerator };
} else {
    // ブラウザ環境での利用
    const g = (typeof self !== 'undefined') ? self : 
              (typeof window !== 'undefined') ? window : globalThis;
    g.AggregatedMarkdownGenerator = AggregatedMarkdownGenerator;
}